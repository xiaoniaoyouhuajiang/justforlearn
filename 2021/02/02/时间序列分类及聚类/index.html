<!DOCTYPE html>
<html lang="">
    <!-- title -->




<!-- keywords -->




<head>
    <!-- hexo-inject:begin --><!-- hexo-inject:end --><meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no" >
    <meta name="author" content="bilibili_master">
    <meta name="renderer" content="webkit">
    <meta name="copyright" content="bilibili_master">
    
    <meta name="keywords" content="hexo,hexo-theme,hexo-blog">
    
    <meta name="description" content="">
    <meta http-equiv="Cache-control" content="no-cache">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1"/>
    <title>时间序列算法的研究 · Doge&#39;s lab</title>
    <style type="text/css">
    @font-face {
        font-family: 'Oswald-Regular';
        src: url("/font/Oswald-Regular.ttf");
    }

    body {
        margin: 0;
    }

    header,
    footer,
    .back-top,
    .sidebar,
    .container,
    .site-intro-meta,
    .toc-wrapper {
        display: none;
    }

    .site-intro {
        position: relative;
        z-index: 3;
        width: 100%;
        /* height: 50vh; */
        overflow: hidden;
    }

    .site-intro-placeholder {
        position: absolute;
        z-index: -2;
        top: 0;
        left: 0;
        width: calc(100% + 300px);
        height: 100%;
        background: repeating-linear-gradient(-45deg, #444 0, #444 80px, #333 80px, #333 160px);
        background-position: center center;
        transform: translate3d(-226px, 0, 0);
        animation: gradient-move 2.5s ease-out 0s infinite;
    }

    @keyframes gradient-move {
        0% {
            transform: translate3d(-226px, 0, 0);
        }
        100% {
            transform: translate3d(0, 0, 0);
        }
    }

</style>

    <link rel="preload" href= "/css/style.css?v=20180824" as="style" onload="this.onload=null;this.rel='stylesheet'" />
    <link rel="stylesheet" href= "/css/mobile.css?v=20180824" media="(max-width: 980px)">
    
    <link rel="preload" href="https://cdnjs.cloudflare.com/ajax/libs/fancybox/3.2.5/jquery.fancybox.min.css" as="style" onload="this.onload=null;this.rel='stylesheet'" />
    
    <!-- /*! loadCSS. [c]2017 Filament Group, Inc. MIT License */
/* This file is meant as a standalone workflow for
- testing support for link[rel=preload]
- enabling async CSS loading in browsers that do not support rel=preload
- applying rel preload css once loaded, whether supported or not.
*/ -->
<script>
(function( w ){
	"use strict";
	// rel=preload support test
	if( !w.loadCSS ){
		w.loadCSS = function(){};
	}
	// define on the loadCSS obj
	var rp = loadCSS.relpreload = {};
	// rel=preload feature support test
	// runs once and returns a function for compat purposes
	rp.support = (function(){
		var ret;
		try {
			ret = w.document.createElement( "link" ).relList.supports( "preload" );
		} catch (e) {
			ret = false;
		}
		return function(){
			return ret;
		};
	})();

	// if preload isn't supported, get an asynchronous load by using a non-matching media attribute
	// then change that media back to its intended value on load
	rp.bindMediaToggle = function( link ){
		// remember existing media attr for ultimate state, or default to 'all'
		var finalMedia = link.media || "all";

		function enableStylesheet(){
			link.media = finalMedia;
		}

		// bind load handlers to enable media
		if( link.addEventListener ){
			link.addEventListener( "load", enableStylesheet );
		} else if( link.attachEvent ){
			link.attachEvent( "onload", enableStylesheet );
		}

		// Set rel and non-applicable media type to start an async request
		// note: timeout allows this to happen async to let rendering continue in IE
		setTimeout(function(){
			link.rel = "stylesheet";
			link.media = "only x";
		});
		// also enable media after 3 seconds,
		// which will catch very old browsers (android 2.x, old firefox) that don't support onload on link
		setTimeout( enableStylesheet, 3000 );
	};

	// loop through link elements in DOM
	rp.poly = function(){
		// double check this to prevent external calls from running
		if( rp.support() ){
			return;
		}
		var links = w.document.getElementsByTagName( "link" );
		for( var i = 0; i < links.length; i++ ){
			var link = links[ i ];
			// qualify links to those with rel=preload and as=style attrs
			if( link.rel === "preload" && link.getAttribute( "as" ) === "style" && !link.getAttribute( "data-loadcss" ) ){
				// prevent rerunning on link
				link.setAttribute( "data-loadcss", true );
				// bind listeners to toggle media back
				rp.bindMediaToggle( link );
			}
		}
	};

	// if unsupported, run the polyfill
	if( !rp.support() ){
		// run once at least
		rp.poly();

		// rerun poly on an interval until onload
		var run = w.setInterval( rp.poly, 500 );
		if( w.addEventListener ){
			w.addEventListener( "load", function(){
				rp.poly();
				w.clearInterval( run );
			} );
		} else if( w.attachEvent ){
			w.attachEvent( "onload", function(){
				rp.poly();
				w.clearInterval( run );
			} );
		}
	}


	// commonjs
	if( typeof exports !== "undefined" ){
		exports.loadCSS = loadCSS;
	}
	else {
		w.loadCSS = loadCSS;
	}
}( typeof global !== "undefined" ? global : this ) );
</script>

    <link rel="icon" href= "/assets/favicon.ico" />
    <link rel="preload" href="https://cdn.jsdelivr.net/npm/webfontloader@1.6.28/webfontloader.min.js" as="script" />
    <link rel="preload" href="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js" as="script" />
    <link rel="preload" href="/scripts/main.js" as="script" />
    <link rel="preload" as="font" href="/font/Oswald-Regular.ttf" crossorigin>
    <link rel="preload" as="font" href="https://at.alicdn.com/t/font_327081_1dta1rlogw17zaor.woff" crossorigin>
    
    <!-- fancybox -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/fancybox/3.2.5/jquery.fancybox.min.js" defer></script>
    <!-- 百度统计  -->
    
    <!-- 谷歌统计  -->
    
	
	<link href="https://cdn.bootcss.com/KaTeX/0.7.1/katex.min.css" rel="stylesheet"><!-- hexo-inject:begin --><!-- hexo-inject:end -->

</head>

    
        <body class="post-body">
    
    
<!-- hexo-inject:begin --><!-- hexo-inject:end --><header class="header">

    <div class="read-progress"></div>
    <div class="header-sidebar-menu">&#xe775;</div>
    <!-- post页的toggle banner  -->
    
    <div class="banner">
            <div class="blog-title">
                <a href="/" >Doge&#39;s lab.</a>
            </div>
            <div class="post-title">
                <a href="#" class="post-name">时间序列算法的研究</a>
            </div>
    </div>
    
    <a class="home-link" href=/>Doge's lab.</a>
</header>
    <div class="wrapper">
        <div class="site-intro" style="







height:50vh;
">
    
    <!-- 主页  -->
    
    
    <!-- 404页  -->
            
    <div class="site-intro-placeholder"></div>
    <div class="site-intro-img" style="background-image: url(/intro/kakaka.jpg)"></div>
    <div class="site-intro-meta">
        <!-- 标题  -->
        <h1 class="intro-title">
            <!-- 主页  -->
            
            时间序列算法的研究
            <!-- 404 -->
            
        </h1>
        <!-- 副标题 -->
        <p class="intro-subtitle">
            <!-- 主页副标题  -->
            
            
            <!-- 404 -->
            
        </p>
        <!-- 文章页meta -->
        
            <div class="post-intros">
                <!-- 文章页标签  -->
                
                
                    <div class="post-intro-read">
                        <span>字数统计: <span class="post-count word-count">2.6k</span>阅读时长: <span class="post-count reading-time">10 min</span></span>
                    </div>
                
                <div class="post-intro-meta">
                    <span class="post-intro-calander iconfont-archer">&#xe676;</span>
                    <span class="post-intro-time">2021/02/02</span>
                    
                    <span id="busuanzi_container_page_pv" class="busuanzi-pv">
                        <span class="iconfont-archer">&#xe602;</span>
                        <span id="busuanzi_value_page_pv"></span>
                    </span>
                    
                    <span class="shareWrapper">
                        <span class="iconfont-archer shareIcon">&#xe71d;</span>
                        <span class="shareText">Share</span>
                        <ul class="shareList">
                            <li class="iconfont-archer share-qr" data-type="qr">&#xe75b;
                                <div class="share-qrcode"></div>
                            </li>
                            <li class="iconfont-archer" data-type="weibo">&#xe619;</li>
                            <li class="iconfont-archer" data-type="qzone">&#xe62e;</li>
                            <li class="iconfont-archer" data-type="twitter">&#xe634;</li>
                            <li class="iconfont-archer" data-type="facebook">&#xe67a;</li>
                        </ul>
                    </span>
                </div>
            </div>
        
    </div>
</div>
        <script>
 
  // get user agent
  var browser = {
    versions: function () {
      var u = window.navigator.userAgent;
      return {
        userAgent: u,
        trident: u.indexOf('Trident') > -1, //IE内核
        presto: u.indexOf('Presto') > -1, //opera内核
        webKit: u.indexOf('AppleWebKit') > -1, //苹果、谷歌内核
        gecko: u.indexOf('Gecko') > -1 && u.indexOf('KHTML') == -1, //火狐内核
        mobile: !!u.match(/AppleWebKit.*Mobile.*/), //是否为移动终端
        ios: !!u.match(/\(i[^;]+;( U;)? CPU.+Mac OS X/), //ios终端
        android: u.indexOf('Android') > -1 || u.indexOf('Linux') > -1, //android终端或者uc浏览器
        iPhone: u.indexOf('iPhone') > -1 || u.indexOf('Mac') > -1, //是否为iPhone或者安卓QQ浏览器
        iPad: u.indexOf('iPad') > -1, //是否为iPad
        webApp: u.indexOf('Safari') == -1, //是否为web应用程序，没有头部与底部
        weixin: u.indexOf('MicroMessenger') == -1, //是否为微信浏览器
        uc: u.indexOf('UCBrowser') > -1 //是否为android下的UC浏览器
      };
    }()
  }
  console.log("userAgent:" + browser.versions.userAgent);

  // callback
  function fontLoaded() {
    console.log('font loaded');
    if (document.getElementsByClassName('site-intro-meta')) {
      document.getElementsByClassName('intro-title')[0].classList.add('intro-fade-in');
      document.getElementsByClassName('intro-subtitle')[0].classList.add('intro-fade-in');
      var postIntros = document.getElementsByClassName('post-intros')[0]
      if (postIntros) {
        postIntros.classList.add('post-fade-in');
      }
    }
  }

  // UC不支持跨域，所以直接显示
  function asyncCb(){
    if (browser.versions.uc) {
      console.log("UCBrowser");
      fontLoaded();
    } else {
      WebFont.load({
        custom: {
          families: ['Oswald-Regular']
        },
        loading: function () {  //所有字体开始加载
          // console.log('loading');
        },
        active: function () {  //所有字体已渲染
          fontLoaded();
        },
        inactive: function () { //字体预加载失败，无效字体或浏览器不支持加载
          console.log('inactive: timeout');
          fontLoaded();
        },
        timeout: 5000 // Set the timeout to two seconds
      });
    }
  }

  function asyncErr(){
    console.warn('script load from CDN failed, will load local script')
  }

  // load webfont-loader async, and add callback function
  function async(u, cb, err) {
    var d = document, t = 'script',
      o = d.createElement(t),
      s = d.getElementsByTagName(t)[0];
    o.src = u;
    if (cb) { o.addEventListener('load', function (e) { cb(null, e); }, false); }
    if (err) { o.addEventListener('error', function (e) { err(null, e); }, false); }
    s.parentNode.insertBefore(o, s);
  }

  var asyncLoadWithFallBack = function(arr, success, reject) {
      var currReject = function(){
        reject()
        arr.shift()
        if(arr.length)
          async(arr[0], success, currReject)
        }

      async(arr[0], success, currReject)
  }

  asyncLoadWithFallBack([
    "https://cdn.jsdelivr.net/npm/webfontloader@1.6.28/webfontloader.min.js", 
    "https://cdn.bootcss.com/webfont/1.6.28/webfontloader.js",
    "/lib/webfontloader.min.js"
  ], asyncCb, asyncErr)
</script>        
        <img class="loading" src="/assets/loading.svg" style="display: block; margin: 6rem auto 0 auto; width: 6rem; height: 6rem;" />
        <div class="container container-unloaded">
            <main class="main post-page">
    <article class="article-entry">
        <h1 id="时间序列算法的研究"><a href="#时间序列算法的研究" class="headerlink" title="时间序列算法的研究"></a>时间序列算法的研究</h1><hr>
<p>在典型的分类问题中，您将获得一组输入要素和一组离散输出类，并且您希望对两者之间的关系进行建模。<br>你可以使用无数的分类算法来解决这个问题 - 支持向量机，朴素贝叶斯，k-NN等。<br>但是如果输入特征不是独立的，比如时间序列数据呢？<br>在这种情况下，SVM和朴素贝叶斯不是一个好的选择，因为他们假设输入特征是独立的。 k-NN算法仍然可以工作，但它依赖于输入示例之间的相似性度量的概念。现在问题变成<em>我们如何衡量两个时间序列</em>之间的相似性？</p>
<h3 id="假如使用欧式距离方法"><a href="#假如使用欧式距离方法" class="headerlink" title="假如使用欧式距离方法"></a>假如使用欧式距离方法</h3><p>两个时间序列 Q 和长度 n 的 C 之间的欧几里德距离定义为</p>
<script type="math/tex; mode=display">d(Q,C) = \sqrt{\sum^n_{i=1}[Q(i)-C(i)]^2}</script><p>乍一看，似乎只是简单地计算两个时间序列之间的欧几里德距离就可以让我们对它们之间的相似性有一个很好的了解。毕竟，相同时间序列之间的欧几里德距离为零，并且非常不同的时间序列之间的欧几里德距离很大。然而，在我们确定欧几里德距离作为相似性度量之前，我们应该清楚地说明我们所需的标准，以确定两个时间序列之间的相似性</p>
<p><strong> 然而。。</strong><br><em>通过良好的相似性度量，两个时间序列中的微小变化应导致其相似性的微小变化。关于欧几里德距离，这对于y轴的变化是正确的，但是对于时间轴的变化（即压缩和拉伸）则不然。请考虑以下示例。</em></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pylab <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> qgrid</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">x=np.linspace(<span class="number">0</span>,<span class="number">50</span>,<span class="number">100</span>)</span><br><span class="line">ts1=pd.Series(<span class="number">3.1</span>*np.sin(x/<span class="number">1.5</span>)+<span class="number">3.5</span>)</span><br><span class="line">ts2=pd.Series(<span class="number">2.2</span>*np.sin(x/<span class="number">3.5</span>+<span class="number">2.4</span>)+<span class="number">3.2</span>)</span><br><span class="line">ts3=pd.Series(<span class="number">0.04</span>*x+<span class="number">3.0</span>)</span><br><span class="line">test=pd.DataFrame(x)</span><br><span class="line">test=qgrid.show_grid(test,show_toolbar=<span class="keyword">True</span>)</span><br><span class="line">test</span><br><span class="line">ts1.plot()</span><br><span class="line">ts2.plot()</span><br><span class="line">ts3.plot()</span><br><span class="line"></span><br><span class="line">plt.ylim(<span class="number">-2</span>,<span class="number">10</span>)</span><br><span class="line">plt.legend([<span class="string">'ts1'</span>,<span class="string">'ts2'</span>,<span class="string">'ts3'</span>])</span><br><span class="line">plt.show()</span><br><span class="line">test</span><br></pre></td></tr></table></figure>
<p><img src="https://thumbnail0.baidupcs.com/thumbnail/75545d55728341603c3285b27578d882?fid=1076969831-250528-304040274284946&amp;time=1537837200&amp;rt=sh&amp;sign=FDTAER-DCb740ccc5511e5e8fedcff06b081203-H4ONS0zHZjrUgm7sE0L7fLZaS%2F4%3D&amp;expires=8h&amp;chkv=0&amp;chkbd=0&amp;chkpc=&amp;dp-logid=6201672027968632425&amp;dp-callid=0&amp;size=c710_u400&amp;quality=100&amp;vuk=-&amp;ft=video" alt="png"></p>
<pre><code>A Jupyter Widget
</code></pre><p>在上面的例子中，很明显$ts1$和$ts2$最相似（它们都是不同变换下的$sin$函数）。 $ts3$显然是最不同的。让我们计算欧几里德距离$d(ts1,ts2)$和$d(ts1,ts3)$，看看欧几里德距离度量是否与我们的直觉告诉我们的一致。让我们首先创建一个函数来计算两个时间序列之间的欧几里德距离。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> math <span class="keyword">import</span> sqrt</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">euclid_dist</span><span class="params">(t1,t2)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> sqrt(sum((t1-t2)**<span class="number">2</span>))</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">print(<span class="string">'第一组:'</span>,euclid_dist(ts1,ts2),<span class="string">'   第二组:'</span>,euclid_dist(ts1,ts3))</span><br></pre></td></tr></table></figure>
<pre><code>第一组: 26.959216037969345    第二组: 23.189249190311056
</code></pre><p>​    </p>
<p>这并不好，因为根据欧几里德距离测量，$ts1$更类似于$ts3$而不是$ts2$，这与我们的直觉相矛盾。这是使用欧几里德距离测量的问题。当它遇到时间轴上时，它经常产生失真问题。解决这个问题的方法是使用动态时间扭曲。</p>
<h2 id="动态时间扭曲-Dynamic-Time-Warping"><a href="#动态时间扭曲-Dynamic-Time-Warping" class="headerlink" title="动态时间扭曲(Dynamic Time Warping)"></a>动态时间扭曲(Dynamic Time Warping)</h2><p>动态时间扭曲能在两个时间序列之间找到最佳的非线性对齐。因此，由于时间轴的失真，对准之间的欧几里德距离对于悲观相似性测量更不可接受。然而，要为此付出代价是因为动态时间扭曲在所使用的时间序列的长度上是二次方的。</p>
<p>动态时间扭曲以下列方式工作。考虑两个相同长度$n$的时间序列$Q$和$C$，其中<script type="math/tex">Q=q_1,q_2,...,q_n</script>和<script type="math/tex">C=c_1,c_2,...,c_n</script>我们要做的第一件事是构造一个$n\times n$矩阵，其$i,j^{th}$元素是$q_i$和$c_j$之间的欧几里德距离。我们希望找到通过此矩阵的路径，以最小化累积距离。然后，该路径确定两个时间序列之间的最佳对齐。应当注意，时间序列中的一个点可以映射到其他时间序列中的多个点。</p>
<p>让我们调用路径$W$，其中<script type="math/tex">W=w_1,w_2,...,w_K</script>其中$W$的每个元素表示$Q$中的一个点$i$和$C$中的一个点$j$之间的距离，即$w_k=(q_i-c_j)^2$</p>
<p>因此，我们希望找到具有最小欧几里德距离的路径<script type="math/tex">W^*=argmin_W(\sqrt{\sum_{k=1}^Kw_k})</script>通过动态编程找到最佳路径，特别是下面的递归函数。 <script type="math/tex">\gamma(i,j)=d(q_i,c_j)+min ( \gamma(i-1,j-1),\gamma(i-1,j),\gamma(i,j-1))</script></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">DTWDistance</span><span class="params">(s1, s2)</span>:</span></span><br><span class="line">    DTW=&#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(len(s1)):</span><br><span class="line">        DTW[(i, <span class="number">-1</span>)] = float(<span class="string">'inf'</span>)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(len(s2)):</span><br><span class="line">        DTW[(<span class="number">-1</span>, i)] = float(<span class="string">'inf'</span>)</span><br><span class="line">    DTW[(<span class="number">-1</span>, <span class="number">-1</span>)] = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(len(s1)):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(len(s2)):</span><br><span class="line">            dist= (s1[i]-s2[j])**<span class="number">2</span></span><br><span class="line">            DTW[(i, j)] = dist + min(DTW[(i<span class="number">-1</span>, j)],DTW[(i, j<span class="number">-1</span>)], DTW[(i<span class="number">-1</span>, j<span class="number">-1</span>)])</span><br><span class="line">		</span><br><span class="line">    <span class="keyword">return</span> sqrt(DTW[len(s1)<span class="number">-1</span>, len(s2)<span class="number">-1</span>])</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">print(DTWDistance(ts1,ts2))</span><br><span class="line">print(DTWDistance(ts1,ts3))</span><br></pre></td></tr></table></figure>
<pre><code>17.929718468641138
21.549494824404572
</code></pre><p>如您所见，我们的结果已经从我们仅使用欧几里德距离测量时发生了变化。现在，与我们的直觉一致，$ts2$显示出比$ts3$更类似于$ts1$。</p>
<h3 id="加快动态时间扭曲"><a href="#加快动态时间扭曲" class="headerlink" title="加快动态时间扭曲"></a>加快动态时间扭曲</h3><p>动态时间扭曲具有$O(nm)$的复杂性，其中$n$是第一个时间序列的长度，$m$是第二个时间序列的长度。如果您在长时间序列数据上多次执行动态时间扭曲，这可能会非常昂贵。但是，有几种方法可以加快速度。第一种是强制执行局部性约束。这是假设如果$i$和$j$相距太远则不能匹配$q_i$和$c_j$。阈值由窗口大小$w$确定。这样，仅考虑该窗口内的映射，这加速了内循环。以下是修改后的代码，其中包括窗口大小$w$。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">DTWDistance</span><span class="params">(s1, s2,w)</span>:</span></span><br><span class="line">    DTW=&#123;&#125;</span><br><span class="line">    </span><br><span class="line">    w = max(w, abs(len(s1)-len(s2)))</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">-1</span>,len(s1)):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">-1</span>,len(s2)):</span><br><span class="line">            DTW[(i, j)] = float(<span class="string">'inf'</span>)</span><br><span class="line">    DTW[(<span class="number">-1</span>, <span class="number">-1</span>)] = <span class="number">0</span></span><br><span class="line">  </span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(len(s1)):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(max(<span class="number">0</span>, i-w), min(len(s2), i+w)):</span><br><span class="line">            dist= (s1[i]-s2[j])**<span class="number">2</span></span><br><span class="line">            DTW[(i, j)] = dist + min(DTW[(i<span class="number">-1</span>, j)],DTW[(i, j<span class="number">-1</span>)], DTW[(i<span class="number">-1</span>, j<span class="number">-1</span>)])</span><br><span class="line">		</span><br><span class="line">    <span class="keyword">return</span> sqrt(DTW[len(s1)<span class="number">-1</span>, len(s2)<span class="number">-1</span>])</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">print(DTWDistance(ts1,ts2,<span class="number">10</span>))</span><br><span class="line">print(DTWDistance(ts1,ts3,<span class="number">10</span>))</span><br></pre></td></tr></table></figure>
<pre><code>18.59655183841726
22.47248284679103
</code></pre><p>另一种加快速度的方法是使用动态时间扭曲的<em>LB Keogh</em>下限。它被定义为<script type="math/tex">LBKeogh(Q,C)=\sum_{i=1}^n (c_i-U_i)^2I(c_i > U_i)+(c_i-L_i)^2I(c_i < L_i)</script></p>
<p>其中<script type="math/tex">U_i​</script>和<script type="math/tex">L_i​</script>是时间序列$Q​$的上限和下限，定义为<script type="math/tex">U_i=max(q_{i-r}:q_{i+r})​</script>，<script type="math/tex">L_i=min(q_{i-r}:q_{i+r})​</script>定义为达到$r​$，<script type="math/tex">I(\cdot) ​</script>是指标函数。它可以使用以下功能实现。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">LB_Keogh</span><span class="params">(s1,s2,r)</span>:</span></span><br><span class="line">    LB_sum=<span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> ind,i <span class="keyword">in</span> enumerate(s1):</span><br><span class="line">        </span><br><span class="line">        lower_bound=min(s2[(ind-r <span class="keyword">if</span> ind-r&gt;=<span class="number">0</span> <span class="keyword">else</span> <span class="number">0</span>):(ind+r)])</span><br><span class="line">        upper_bound=max(s2[(ind-r <span class="keyword">if</span> ind-r&gt;=<span class="number">0</span> <span class="keyword">else</span> <span class="number">0</span>):(ind+r)])</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> i&gt;upper_bound:</span><br><span class="line">            LB_sum=LB_sum+(i-upper_bound)**<span class="number">2</span></span><br><span class="line">        <span class="keyword">elif</span> i&lt;lower_bound:</span><br><span class="line">            LB_sum=LB_sum+(i-lower_bound)**<span class="number">2</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> sqrt(LB_sum)</span><br></pre></td></tr></table></figure>
<p>让我们来看看现在ts1与另外两个序列的距离</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">print(LB_Keogh(ts1,ts2,<span class="number">20</span>))</span><br><span class="line">print(LB_Keogh(ts1,ts3,<span class="number">20</span>))</span><br></pre></td></tr></table></figure>
<pre><code>6.253892351594148
19.959547869419758
</code></pre><p><em>LB Keogh</em>下界方法是线性的，而动态时间扭曲是复杂性的二次方，这使得它在搜索大量时间序列时非常有利。</p>
<h2 id="分类以及聚类"><a href="#分类以及聚类" class="headerlink" title="分类以及聚类"></a>分类以及聚类</h2><p>现在我们有一个可靠的方法来确定两个时间序列之间的相似性，我们可以使用k-NN算法进行分类。根据经验，当$k=1$时，效果最好。以下是使用动态时间扭曲欧几里德距离的1-NN算法。在该算法中，$train$是时间序列示例的训练集，其中时间序列所属的类被附加到时间序列的末尾。 $test$是您试图预测其对应类的测试集。在该算法中，对于测试集中的每个时间序列，必须通过训练集中的所有点执行搜索，以便找到最相似的点。鉴于动态时间扭曲的时间复杂度是二次的，这计算时间显得过于奢侈。我们可以使用<em>LB Keogh</em>下限来加速分类。计算<em>LB Keogh</em>比执行动态时间扭曲要“便宜”得多。从$LB Keogh(Q,C) \leq DTW(Q,C)$开始，我们可以消除与当前最相似的时间序列以外的不可能更相似的时间序列。通过这种方式，我们消除了许多不必要的动态时间扭曲计算时间。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.metrics <span class="keyword">import</span> classification_report</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">knn</span><span class="params">(train,test,w)</span>:</span></span><br><span class="line">    preds=[]</span><br><span class="line">    <span class="keyword">for</span> ind,i <span class="keyword">in</span> enumerate(test):</span><br><span class="line">        min_dist=float(<span class="string">'inf'</span>)</span><br><span class="line">        closest_seq=[]</span><br><span class="line">        <span class="comment">#print ind</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> train:</span><br><span class="line">            <span class="keyword">if</span> LB_Keogh(i[:<span class="number">-1</span>],j[:<span class="number">-1</span>],<span class="number">5</span>)&lt;min_dist:</span><br><span class="line">                dist=DTWDistance(i[:<span class="number">-1</span>],j[:<span class="number">-1</span>],w)</span><br><span class="line">                <span class="keyword">if</span> dist&lt;min_dist:</span><br><span class="line">                    min_dist=dist</span><br><span class="line">                    closest_seq=j</span><br><span class="line">        preds.append(closest_seq[<span class="number">-1</span>])</span><br><span class="line">    <span class="keyword">return</span> classification_report(test[:,<span class="number">-1</span>],preds)</span><br></pre></td></tr></table></figure>
<p>现在让我们对一些数据进行测试。我们将使用4的窗口大小。尽管使用了<em>LB Keogh</em>绑定和动态时间扭曲局部性约束来加速代码，但我们仍可能需要几分钟才能运行，下面先来加载数据，并可视化视图。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">train = np.genfromtxt(<span class="string">'datasets/train.csv'</span>, delimiter=<span class="string">'\t'</span>)</span><br><span class="line">test = np.genfromtxt(<span class="string">'datasets/test.csv'</span>, delimiter=<span class="string">'\t'</span>)</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">train = pd.DataFrame(train)</span><br><span class="line">test = pd.DataFrame(test)</span><br><span class="line">tem=qgrid.show_grid(test,show_toolbar=<span class="keyword">True</span>)</span><br><span class="line">tem</span><br><span class="line"><span class="comment">##train = np.genfromtxt('datasets/train.csv', delimiter='\t')</span></span><br><span class="line"><span class="comment">##test = np.genfromtxt('datasets/test.csv', delimiter='\t')</span></span><br></pre></td></tr></table></figure>
<pre><code>A Jupyter Widget
</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">print(knn(train,test,<span class="number">4</span>))</span><br></pre></td></tr></table></figure>
<pre><code>             precision    recall  f1-score   support

        1.0       1.00      0.96      0.98        50
        2.0       0.96      1.00      0.98        50
        3.0       1.00      1.00      1.00        50
        4.0       0.98      1.00      0.99        50
        5.0       1.00      1.00      1.00        50
        6.0       1.00      0.98      0.99        50

avg / total       0.99      0.99      0.99       300
</code></pre><p>​    </p>
<p>同样的想法也可以应用于k均值聚类。在该算法中，簇的数量设置为<em>apriori</em>，并且类似的时间序列被聚集在一起。下面是实现的代码</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> random</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">k_means_clust</span><span class="params">(data,num_clust,num_iter,w=<span class="number">5</span>)</span>:</span></span><br><span class="line">    centroids=random.sample(data,num_clust)</span><br><span class="line">    counter=<span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> n <span class="keyword">in</span> range(num_iter):</span><br><span class="line">        counter+=<span class="number">1</span></span><br><span class="line">        <span class="keyword">print</span> (counter)</span><br><span class="line">        assignments=&#123;&#125;</span><br><span class="line">        <span class="comment">#assign data points to clusters</span></span><br><span class="line">        <span class="keyword">for</span> ind,i <span class="keyword">in</span> enumerate(data):</span><br><span class="line">            min_dist=float(<span class="string">'inf'</span>)</span><br><span class="line">            closest_clust=<span class="keyword">None</span></span><br><span class="line">            <span class="keyword">for</span> c_ind,j <span class="keyword">in</span> enumerate(centroids):</span><br><span class="line">                <span class="keyword">if</span> LB_Keogh(i,j,<span class="number">5</span>)&lt;min_dist:</span><br><span class="line">                    cur_dist=DTWDistance(i,j,w)</span><br><span class="line">                    <span class="keyword">if</span> cur_dist&lt;min_dist:</span><br><span class="line">                        min_dist=cur_dist</span><br><span class="line">                        closest_clust=c_ind</span><br><span class="line">            <span class="keyword">if</span> closest_clust <span class="keyword">in</span> assignments:</span><br><span class="line">                assignments[closest_clust].append(ind)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                assignments[closest_clust]=[]</span><br><span class="line">    </span><br><span class="line">        <span class="comment">#recalculate centroids of clusters</span></span><br><span class="line">        <span class="keyword">for</span> key <span class="keyword">in</span> assignments:</span><br><span class="line">            clust_sum=<span class="number">0</span></span><br><span class="line">            <span class="keyword">for</span> k <span class="keyword">in</span> assignments[key]:</span><br><span class="line">                clust_sum=clust_sum+data[k]</span><br><span class="line">            centroids[key]=[m/len(assignments[key]) <span class="keyword">for</span> m <span class="keyword">in</span> clust_sum]</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> centroids</span><br></pre></td></tr></table></figure>

    </article>
    <!-- license  -->
    
        <div class="license-wrapper">
            <p>原文作者：<a href="https://xiaoniaoyouhuajiang.github.io">bilibili_master</a>
            <p>原文链接：<a href="https://xiaoniaoyouhuajiang.github.io/2021/02/02/时间序列分类及聚类/">https://xiaoniaoyouhuajiang.github.io/2021/02/02/时间序列分类及聚类/</a>
            <p>发表日期：<a href="https://xiaoniaoyouhuajiang.github.io/2021/02/02/时间序列分类及聚类/">February 2nd 2021, 9:41:03 am</a>
            <p>更新日期：<a href="https://xiaoniaoyouhuajiang.github.io/2021/02/02/时间序列分类及聚类/">September 25th 2018, 2:09:41 pm</a>
            <p>版权声明：本文采用<a rel="license" href="http://creativecommons.org/licenses/by-nc/4.0/">知识共享署名-非商业性使用 4.0 国际许可协议</a>进行许可</p>
        </div>
    
    <!-- paginator  -->
    <ul class="post-paginator">
        <li class="next">
            
                <div class="nextSlogan">Next Post</div>
                <a href= "/2021/02/02/简单谈谈pymc/" title= "受到广泛应用的贝叶斯方法(python实验)">
                    <div class="nextTitle">受到广泛应用的贝叶斯方法(python实验)</div>
                </a>
            
        </li>
        <li class="previous">
            
                <div class="prevSlogan">Previous Post</div>
                <a href= "/2019/08/04/重要的题/" title= "check">
                    <div class="prevTitle">check</div>
                </a>
            
        </li>
    </ul>
    <!-- 评论插件 -->
    <!-- 来必力City版安装代码 -->

<!-- City版安装代码已完成 -->
    
    
    <!-- partial('_partial/comment/changyan') -->
    <!--PC版-->


    
    

    <!-- 评论 -->
</main>
            <!-- profile -->
            
        </div>
        <footer class="footer footer-unloaded">
    <!-- social  -->
    
    <div class="social">
        
    
        
            
                <a href="mailto:2583473505@qq.com" class="iconfont-archer email" title=email ></a>
            
        
    
        
            
                <a href="//github.com/xiaoniaoyouhuajiang" class="iconfont-archer github" target="_blank" title=github></a>
            
        
    
        
            
                <span class="iconfont-archer wechat" title=wechat>
                  
                  <img class="profile-qr" src="/assets/my_wechat.png" />
                </span>
            
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    

    </div>
    
    <!-- powered by Hexo  -->
    <div class="copyright">
        <span id="hexo-power">Powered by <a href="https://hexo.io/" target="_blank">Hexo</a></span><span class="iconfont-archer power">&#xe635;</span><span id="theme-info">theme <a href="https://github.com/fi3ework/hexo-theme-archer" target="_blank">Archer</a></span>
    </div>
    <!-- 不蒜子  -->
    
    <div class="busuanzi-container">
    
     
    <span id="busuanzi_container_site_pv">PV: <span id="busuanzi_value_site_pv"></span> :)</span>
    
    </div>
    
</footer>
    </div>
    <!-- toc -->
    
    <div class="toc-wrapper" style=
    







top:50vh;

    >
        <div class="toc-catalog">
            <span class="iconfont-archer catalog-icon">&#xe613;</span><span>CATALOG</span>
        </div>
        <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#时间序列算法的研究"><span class="toc-number">1.</span> <span class="toc-text">时间序列算法的研究</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#假如使用欧式距离方法"><span class="toc-number">1.0.1.</span> <span class="toc-text">假如使用欧式距离方法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#动态时间扭曲-Dynamic-Time-Warping"><span class="toc-number">1.1.</span> <span class="toc-text">动态时间扭曲(Dynamic Time Warping)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#加快动态时间扭曲"><span class="toc-number">1.1.1.</span> <span class="toc-text">加快动态时间扭曲</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#分类以及聚类"><span class="toc-number">1.2.</span> <span class="toc-text">分类以及聚类</span></a></li></ol></li></ol>
    </div>
    
    <div class="back-top iconfont-archer">&#xe639;</div>
    <div class="sidebar sidebar-hide">
    <ul class="sidebar-tabs sidebar-tabs-active-0">
        <li class="sidebar-tab-archives"><span class="iconfont-archer">&#xe67d;</span><span class="tab-name">Archive</span></li>
        <li class="sidebar-tab-tags"><span class="iconfont-archer">&#xe61b;</span><span class="tab-name">Tag</span></li>
        <li class="sidebar-tab-categories"><span class="iconfont-archer">&#xe666;</span><span class="tab-name">Cate</span></li>
    </ul>
    <div class="sidebar-content sidebar-content-show-archive">
          <div class="sidebar-panel-archives">
    <!-- 在ejs中将archive按照时间排序 -->
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    <div class="total-and-search">
        <div class="total-archive">
        Total : 6
        </div>
        <!-- search  -->
        
    </div>
    
    <div class="post-archive">
    
    
    
    
    <div class="archive-year"> 2021 </div>
    <ul class="year-list">
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">02/02</span><a class="archive-post-title" href= "/2021/02/02/简单谈谈pymc/" >受到广泛应用的贝叶斯方法(python实验)</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">02/02</span><a class="archive-post-title" href= "/2021/02/02/时间序列分类及聚类/" >时间序列算法的研究</a>
        </li>
    
    
    
    
    
        </ul>
    
    <div class="archive-year"> 2019 </div>
    <ul class="year-list">
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">08/04</span><a class="archive-post-title" href= "/2019/08/04/重要的题/" >check</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">07/30</span><a class="archive-post-title" href= "/2019/07/30/punishment/" >punishment</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">07/29</span><a class="archive-post-title" href= "/2019/07/29/往年/" >learn_plan</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">07/22</span><a class="archive-post-title" href= "/2019/07/22/learn-record/" >learn_record</a>
        </li>
    
    </div>
  </div>
        <div class="sidebar-panel-tags">
    <div class="sidebar-tags-name">
    
        <span class="sidebar-tag-name" data-tags="learn"><span class="iconfont-archer">&#xe606;</span>learn</span>
    
    </div>
    <div class="iconfont-archer sidebar-tags-empty">&#xe678;</div>
    <div class="tag-load-fail" style="display: none; color: #ccc; font-size: 0.6rem;">
    缺失模块。<br/>
    1、请确保node版本大于6.2<br/>
    2、在博客根目录（注意不是archer根目录）执行以下命令：<br/>
    <span style="color: #f75357; font-size: 1rem; line-height: 2rem;">npm i hexo-generator-json-content --save</span><br/>
    3、在根目录_config.yml里添加配置：
    <pre style="color: #787878; font-size: 0.6rem;">
jsonContent:
  meta: false
  pages: false
  posts:
    title: true
    date: true
    path: true
    text: false
    raw: false
    content: false
    slug: false
    updated: false
    comments: false
    link: false
    permalink: false
    excerpt: false
    categories: true
    tags: true</pre>
    </div> 
    <div class="sidebar-tags-list"></div>
</div>
        <div class="sidebar-panel-categories">
    <div class="sidebar-categories-name">
    
    </div>
    <div class="iconfont-archer sidebar-categories-empty">&#xe678;</div>
    <div class="sidebar-categories-list"></div>
</div>
    </div>
</div> 
    <script>
    var siteMeta = {
        root: "/",
        author: "bilibili_master"
    }
</script>
    <!-- CDN failover -->
    <script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script>
    <script type="text/javascript">
        if (typeof window.$ === 'undefined')
        {
            console.warn('jquery load from jsdelivr failed, will load local script')
            document.write('<script src="/lib/jquery.min.js">\x3C/script>')
        }
    </script>
    <script src="/scripts/main.js"></script>
    <!-- algolia -->
    
    <!-- busuanzi  -->
    
    <script async src="//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    
    <!-- CNZZ  -->
    
    </div>
    <!-- async load share.js -->
    
        <script src="/scripts/share.js" async></script>    
     
    <script type="text/x-mathjax-config">
    MathJax.Hub.Config({
        tex2jax: {
            inlineMath: [ ["$","$"], ["\\(","\\)"] ],
            skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code'],
            processEscapes: true
        }
    });
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax();
        for (var i = 0; i < all.length; ++i)
            all[i].SourceElement().parentNode.className += ' has-jax';
    });
</script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-MML-AM_CHTML"></script><!-- hexo-inject:begin --><!-- Begin: Injected MathJax -->
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({"tex2jax":{"inlineMath":[["$","$"],["\\(","\\)"]],"skipTags":["script","noscript","style","textarea","pre","code"],"processEscapes":true},"TeX":{"equationNumbers":{"autoNumber":"AMS"}}});
</script>

<script type="text/x-mathjax-config">
  MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
      all[i].SourceElement().parentNode.className += ' has-jax';
    }
  });
</script>

<script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js">
</script>
<!-- End: Injected MathJax -->
<!-- hexo-inject:end -->
</body>
</html>


